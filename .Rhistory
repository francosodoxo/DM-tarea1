data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
afect_2010 <- with(afectados,afectados[Muestra == "Regional" & Anio == 2010, ])
library(tidyverse)
# Informacion del dataframe
glimpse(afectados)
# Informacion del dataframe
glimpse(afectados)
# Informacion del dataframe
glimpse(afectados)
# Informacion del dataframe
glimpse(afectados)
# Informacion del dataframe
glimpse(afectados)
library(tidyverse)
# Se asume que los archivos se encuentran en el w.d., si no los tienes descargados, lo siguiente fallará:
tipos <- read.table("accidentes_2010_2011.txt")
x <- c(1, 2, 3)
x^2
x <- c(1, 2, 3)
x^2
# Un vector cuyos valores son los enteros 1 2 3
c(1, 2, 3)
# Un vector cuyos valores son caracteres a,b,c
c("a", "b", "c")
# Un vector cuyos valores tienen nombre
c(a = 1, b = 2, c = 3)
# Se asigna el valor 5 a la variable a
a <- 5
# La asignacion no imprime el resultado, para ello hay que llamar directamente a la variable
a
# Una forma de asignar y evaluar a la vez es usar paréntesis
(a <- 5)
# Se asigna un arreglo a a2
a2 <- c(1, a + 1, a - 1)
a2
# Se asigna un arreglo a a3 con encabezados incluidos
a3 <- c(a = 1, b = 2, c = a + 2)
names(a3) # muestro los encabezados de a3
# c() también sirve para "combinar" valores
# de esta forma se puede adjuntar valores a un vector
# nota que los números y caracteres son vectores de largo 1
a <- c(1, 2, 3)
b <- c(a, 4, 5, 6)
b
# Vector que va de 1 a 10
seq(1, 10)
# Azúcar sintáctico para lo anterior
1:10
# Vector que va de 1 a 9, cada 2
seq(1, 10, 2)
# Repetir un valor N veces
rep(5, 3)
# Repetir un vector N veces
rep(c(1, 2), 3)
# Suma los valores de un vector
sum(c(1, 2, 3))
# Largo del vector
length(c(1, 2, 3))
# Operaciones típicas
# Nota que las funciones están vectorizadas, es decir, funcionan sobre escalares y vectores (recuerda que un escalar es un vector de largo 1)
a <- c(1, 3, 5, 7)
# Exponencial
exp(a)
# Suma
sum(a)
# Logaritmo natural
log(a)
# Log base 10
log10(a)
# Promedio
mean(a)
# Desv estandar
sd(a)
# Mediana
median(a)
# Definimos una tabla con dos columnas, `x` e `y`, cuyos valores son como sigue
d <- data.frame(x = c(10, 20, 30), y = c("a", "b", "c"))
# Muestra todo el data frame, note como se crean los encabezados.
d
# Para mostrar sólo la columna x.
d$x
# Para mostrar sólo la columna y.
d$y
# Para indicar el número de filas de d.
nrow(d)
# Para indicar el número de columnas de d.
ncol(d)
# Para indicar el número de filas y columnas de d
dim(d)
tipos <- read.table("https://users.dcc.uchile.cl/~hsarmien/mineria/datasets/accidentes_2010_2011.txt")
afectados <- read.table("https://users.dcc.uchile.cl/~hsarmien/mineria/datasets/afectados_2010_2011.txt")
str(tipos)
str(afectados)
head(afectados)
nrow(afectados)
summary(afectados)
# Promedio columna Cantidad
mean(afectados$Cantidad)
# Desviacion estandar
sd(afectados$Cantidad)
# Minimo (maximo)
min(afectados$Cantidad)
# Mediana, el valor que es mayor que el 50% de los datos
median(afectados$Cantidad)
# Cuantiles, los valores que son mayores que una fracción $q$ de los datos
quantile(afectados$Cantidad)
quantile(tipos$Cantidad, probs = c(0, .5, .8, .9))
# Diferencia entre cuartil 3 y cuartil 1  (Q3 - Q1), o cuantil 0.75 y cuantil 0.25
IQR(tipos$Cantidad)
# Muestra sólo la columna Cantidad
# Note que el resultado de esta operación es un Vector
head(afectados$Cantidad)
# en R los índices parten desde 1
# note que el output en este caso es un data frame
head(afectados[5])
head(afectados["Cantidad"])
# se puede seleccionar más de una columna
head(afectados[c(1, 5)])
head(afectados[c("Muestra", "Cantidad")])
# fila 2, columna 5
# el resultado es un vector
afectados[2, 5]
# De la fila 2, muestra todas las columnas
# el resultado es un data frame
afectados[2, ]
head(afectados[2])
# Muestra la columna Cantidad
# En este caso, el output es un vector
head(afectados[, c("Cantidad")])
# Muestra los primeros 6 datos y todas excepto la primera columna
afectados[0:6, -1]
# Para cada valor de la columna Anio, indica si es 2010 o no (mediante True y False)
head(afectados$Anio == 2010)
# Suma cuantos datos hay en la columna Anio con valor 2010
sum(afectados$Anio == 2010)
sum(is.na(afectados$Anio))
sapply(afectados, function(x) sum(is.na(x)))
# Filtra los datos cuyo año es 2010 y muestra todas las columnas (notar que ahora no muestra TRUE/FALSE)
head(afectados[afectados$Anio == 2010, ])
# Filtramos que la columna Anio sea 2010 y además que la columna Muestra sea Comunal. Se muestran todas las columnas.
head(afectados[afectados$Anio == 2010 & afectados$Muestra == "Comunal", ])
# Filtramos que la columna Anio sea 2010 y además que la columna Muestra sea Comunal. Seleccionamos la Descripcion y la Cantidad
head(afectados[afectados$Anio == 2010 & afectados$Muestra == "Comunal", c("Descripcion", "Cantidad")])
with(afectados, afectados[Anio == 2010 & Descripcion == "TEMUCO", ])
# Aplica la función suma (sum) a la columna Cantidad en base a los datos de Estado
aggregate(Cantidad ~ Estado, afectados, FUN=sum)
aggregate(Cantidad ~ Estado + Anio, afectados, FUN=sum)
# Muestra los valores diferentes que tiene la columna Estado
unique(afectados$Estado)
# Para hacer el ejemplo pequeño, vamos a tomar los 10 primeros datos de afectados
afectados_reducido <- afectados[1:10,]
# Ordenar ascendentemente la columna Cantidad
afectados_reducido[order(afectados_reducido$Cantidad), ]
# Ordenar descendente la columna Cantidad
afectados_reducido[order(afectados_reducido$Cantidad, decreasing = TRUE), ]
# Otra forma de ordenar descendente
afectados_reducido[order(-afectados_reducido$Cantidad), ]
a = data.frame(ClienteID = c(1:6), Producto = c(rep("Tostadora", 3), rep("Radio", 3)))
b = data.frame(ClienteID = c(2, 4, 6), Comuna = c(rep("Santiago", 2), rep("Puerto Montt", 1)))
a
b
# Inner join
merge(a, b, by = "ClienteID")
# Full outer join
merge(a, b, by = "ClienteID", all = T)
# Left outer join
merge(a, b, by = "ClienteID", all.x = T)
# Right outer join
merge(a, b, by = "ClienteID", all.y = T)
df <- data.frame(x1=1:10, y1=1:10)
df
rowSums(df)
colSums(df)
library("reshape")
d <- data.frame(fecha = c(1,2,1,2),
equipo = c("CC", "CC", "U", "U"),
favor = c(4, 3, 1, 2),
contra = c(0, 2, 4, 0))
d
f1 <- d[d$fecha == 1,]
sum(f1[, c(3,4)])  # c(3,4) indica que tomará la columna 3 y la 4.
sum(f1[, c("favor", "contra")])  # lo mismo
sum(d[d$fecha == 1, 3:4])        # lo mismo
# Fecha y equipo queda fijo, se crea un registro para cada instancia
d2 <- melt(d, id=c("fecha", "equipo"))
d2
f2 <- d2[d2$fecha == 1,]
sum(f2$value)
library(tidyverse)
# Informacion del dataframe
glimpse(afectados)
# Seleccionar una columna del dataframe
afectados %>%
select(Cantidad) %>%
head()
afectados %>%
filter(Anio == 2010 & Muestra == "Comunal") %>%   # Año 2010 y solo comunas
group_by(Estado) %>%                       # Agrupamos por "muerto", "leve", etc
summarise(total = sum(Cantidad)) %>%              # Creamos una nueva columna a partir de cada grupo, llamada "total"
arrange(-total)                                   # Ordenamos descendentemente por "total"
sp <- afectados %>%
spread(key = Estado, value = Cantidad)
head(sp)
# en dplyr podemos generar un vector de nombres usando la notacion:
# en este caso, `Graves:Muertos` creará un vector que considerará el orden del data frame original:
# -> c(Graves, Leves, MenosGraves, Muertos)
sp %>%
gather(Graves:Muertos, key = "Estado", value = "Cantidad") %>%
head()
plot(exp(1:10))
plot(exp(1:10), type = "l")
plot(exp(1:10), main="Mi primer gráfico", xlab="eje x", ylab="eje y", type = "l")
afect_2010 <- with(afectados,afectados[Muestra == "Regional" & Anio == 2010, ])
plot(afect_2010$Estado, afect_2010$Cantidad)
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
library(tm)
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
library(tm)
print(data_tf$localidad)
summary(data_tf)
head(data_tf)
str(data_tf)
ncol(data_tf)
# RESPUESTA
docs <- VectorSource(data_tf[,113])
docs <- Vcorpus(docs)
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
library(tm)
# RESPUESTA
docs <- VectorSource(data_tf[,113])
docs <- Vcorpus(docs)
msj <- read.csv("https://users.dcc.uchile.cl/~hsarmien/mineria/datasets/messages.csv",sep = ";", quote = "\"'")
library(tm)
docs <- VectorSource(msj[, 2])
docs <- VCorpus(docs)
# RESPUESTA
docs <- VectorSource(data_tf[,113])
docs <- VCorpus(docs)
inspect(docs)
inspect(docs)
msj <- read.csv("https://users.dcc.uchile.cl/~hsarmien/mineria/datasets/messages.csv",sep = ";", quote = "\"'")
library(tm)
docs <- VectorSource(msj[, 2])
docs <- VCorpus(docs)
inspect(docs)
docs <- VectorSource(msj[, 2])
docs <- VCorpus(docs)
inspect(docs)
head(inspect(docs))
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
library(tm)
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
library(tm)
docs <- VectorSource(data_tf[,113])
docs <- VCorpus(docs)
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
# RESPUESTA
head(data_tf[data_tf$a_la_salud == 0][1])
data_tf <- read.csv("http://dcc.uchile.cl/~hsarmien/mineria/datasets/actas.txt", header = T)
# RESPUESTA
head(data_tf[data_tf$a_la_salud == 0,1])
# RESPUESTA
data_tf[order(data_tf$justicia, decreasing=TRUE)][1:10,]
# RESPUESTA
selection <- data_tf[order(data_tf$justicia, decreasing=TRUE)]
# RESPUESTA
selection <- data_tf[order(data_tf$justicia, decreasing=TRUE),1][1:10,]
# RESPUESTA
data_tf[order(data_tf$justicia, decreasing=TRUE),1][1:10]
man(order)
?order
order
# RESPUESTA
result <- colSums(data_tf)
# RESPUESTA
result <- colSums(data_tf[,2:113])
result[order(result[1,],decreasing=TRUE)][1:10]
# RESPUESTA
result <- colSums(data_tf[,2:113])
head(result)
result[order(result[1,],decreasing=TRUE)][1:10]
# RESPUESTA
result <- colSums(data_tf[,2:113])
head(result)
dim(result)
result[order(result[1,],decreasing=TRUE)][1:10]
# RESPUESTA
result <- colSums(data_tf[,2:113])
result[order(decreasing=TRUE)][1:10]
colSums(datatf[,2:113])
colSums(data_tf[,2:113])
?colSums
# RESPUESTA
result <- colSums(data_tf[,2:113],1,113)
# RESPUESTA
result <- .colSums(data_tf[,2:113],1,113)
# RESPUESTA
result <- colSums(data_tf[,2:113])
head(result)
# RESPUESTA
result <- colSums(data_tf[,2:113],dims = 1)
head(result)
# RESPUESTA
result <- colSums(data_tf[,2:113],dims = 2)
# RESPUESTA
result <- colSums(data_tf[,2:113],dims = 1)
head(result)
?order_by
?colSums
# RESPUESTA
result <- .colSums(data_tf[,2:113],1,113)
# RESPUESTA
head(data_tf)
result <- .colSums(data_tf[,2:113],1,113)
# RESPUESTA
head(data_tf[,2:113])
result <- .colSums(data_tf[,2:113],1,113)
# RESPUESTA
dim(data_tf[,2:113])
# RESPUESTA
colSums(data_tf[,2:113],dims=2)
# Se suman todas las filas y las 10 localidades que tienen mayor valor se muestran.
rowSums(data_tf)
# Se suman todas las filas y las 10 localidades que tienen mayor valor se muestran.
rowSums(data_tf[,2:113])
# Se suman todas las filas y las 10 localidades que tienen mayor valor se muestran.
head(rowSums(data_tf[,2:113]))
# RESPUESTA
colSums(data_tf[,2:113])
# RESPUESTA
head(data_tf[,2:113])
